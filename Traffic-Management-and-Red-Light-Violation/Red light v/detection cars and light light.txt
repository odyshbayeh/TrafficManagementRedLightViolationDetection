pip install -q ultralytics

import cv2
import torch
from ultralytics import YOLO
import matplotlib.pyplot as plt





model = YOLO('yolov8x.pt')   # Large


#SORT
!pip install filterpy --quiet

import os
import shutil
if os.path.exists('/kaggle/working/sort.py'):
    os.remove('/kaggle/working/sort.py')
if os.path.exists('/kaggle/working/sort'):
    shutil.rmtree('/kaggle/working/sort')
!git clone https://github.com/abewley/sort.git

import sys
sys.path.append('/kaggle/working/sort')


sort_file = '/kaggle/working/sort/sort.py'
with open(sort_file, 'r') as f:
    lines = f.readlines()
with open(sort_file, 'w') as f:
    for line in lines:
        if "matplotlib.use('TkAgg')" in line:
            f.write("# " + line)
        else:
            f.write(line)

from sort import Sort



import cv2
import numpy as np
from ultralytics import YOLO
import pandas as pd
import torch

if os.path.exists("snapshots"):
    shutil.rmtree("snapshots")
os.makedirs("snapshots", exist_ok=True)

saved_ids = set()
last_box_side = {}

if torch.cuda.is_available():
    print("CUDA is available! Using GPU:", torch.cuda.get_device_name(0))
    device = 0
else:
    print("CUDA is NOT available! Using CPU.")
    device = 'cpu'

video_path = '/kaggle/input/redlight/output_video.mp4'
cap = cv2.VideoCapture(video_path)
model = YOLO('yolov8x.pt')

out = cv2.VideoWriter(
    'output.mp4',
    cv2.VideoWriter_fourcc(*'mp4v'),
    25,
    (int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)), int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))
)

tracker = Sort(max_age=10, min_hits=2, iou_threshold=0.25)

line_start = (1113, 1520)
line_end   = (2300, 1532)

roi1_x1, roi1_y1, roi1_x2, roi1_y2 = 0, 200, 700, 700

polygon_points = [
    (1307, 1480),
    (1957, 757),
    (2564, 870),
    (2370, 1507)
]

def detect_light_state(img):
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    red_hsv = np.array([3, 255, 255])
    yellow_hsv = np.array([28, 255, 255])
    green_hsv = np.array([60, 255, 217])
    h_margin = 10
    s_margin = 50
    v_margin = 40

    def make_mask(center):
        lower = np.array([
            max(center[0] - h_margin, 0),
            max(center[1] - s_margin, 0),
            max(center[2] - v_margin, 0)
        ])
        upper = np.array([
            min(center[0] + h_margin, 179),
            min(center[1] + s_margin, 255),
            min(center[2] + v_margin, 255)
        ])
        return cv2.inRange(hsv, lower, upper)

    masks = {
        'RED': make_mask(red_hsv),
        'YELLOW': make_mask(yellow_hsv),
        'GREEN': make_mask(green_hsv)
    }
    sums = {color: np.sum(mask) for color, mask in masks.items()}
    on_color = max(sums, key=sums.get)
    return on_color

def bottom_mid_side_of_line(box, line_start, line_end):
    x1, y1, x2, y2 = box
    cx = (x1 + x2) / 2
    cy = y2
    val = (line_end[1] - line_start[1]) * (cx - line_start[0]) - (line_end[0] - line_start[0]) * (cy - line_start[1])
    if abs(val) < 1e-3:
        return 0
    elif val > 0:
        return 1
    else:
        return -1

def point_in_polygon(point, polygon_points):
    contour = np.array(polygon_points, dtype=np.int32).reshape((-1,1,2))
    return cv2.pointPolygonTest(contour, point, False) >= 0

results_per_frame = []
unique_ids = set()

plates_buffer = {}   # track_id: [(frame_num, img_crop, box_area), ...]
BUFFER_FRAMES = 100

processing_red = False   
while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        print("End of video or error.")
        break

    frame_num = int(cap.get(cv2.CAP_PROP_POS_FRAMES))

    
    roi1 = frame[roi1_y1:roi1_y2, roi1_x1:roi1_x2]
    results_tl = model(roi1, device=device)[0]
    found_tl = False

    light_state = "NONE"
    for box in results_tl.boxes:
        cls = int(box.cls[0])
        conf = float(box.conf[0])
        if cls == 9 and conf > 0.15:
            x1, y1, x2, y2 = map(int, box.xyxy[0])
            abs_x1, abs_y1 = x1 + roi1_x1, y1 + roi1_y1
            abs_x2, abs_y2 = x2 + roi1_x1, y2 + roi1_y1
            tl_crop = roi1[y1:y2, x1:x2]
            if tl_crop.size > 0:
                h, w = tl_crop.shape[:2]
                cx1, cy1 = int(w * 0.2), int(h * 0.2)
                cx2, cy2 = int(w * 0.8), int(h * 0.8)
                core_crop = tl_crop[cy1:cy2, cx1:cx2]
                light_state = detect_light_state(core_crop)
            else:
                light_state = 'UNKNOWN'
            found_tl = True
            break

    if not found_tl:
        light_state = detect_light_state(roi1)

    # -------- skip frame logic --------
    if light_state == "RED":
        if not processing_red:
            print(f"Entered RED at frame {frame_num}")
        processing_red = True
    else:
        if processing_red:
            print(f"Exited RED at frame {frame_num}")
        processing_red = False

    if not processing_red:
        continue  # skip this frame

   
    if light_state == "RED":
        line_color = (0, 0, 255)
    elif light_state == "YELLOW":
        line_color = (0, 255, 255)
    elif light_state == "GREEN":
        line_color = (0, 255, 0)
    else:
        line_color = (255, 255, 255)
    cv2.line(frame, line_start, line_end, line_color, thickness=2)

    results_all = model(frame, device=device)[0]
    dets = []
    for box in results_all.boxes:
        cls = int(box.cls[0])
        conf = float(box.conf[0])
        if cls in [2, 3, 5, 7] and conf > 0.15:
            x1, y1, x2, y2 = map(int, box.xyxy[0])
            overlap_x = max(0, min(x2, roi1_x2) - max(x1, roi1_x1))
            overlap_y = max(0, min(y2, roi1_y2) - max(y1, roi1_y1))
            overlap_area = overlap_x * overlap_y
            box_area = (x2 - x1) * (y2 - y1)
            if box_area > 0 and (overlap_area / box_area) > 0.1:
                continue
            dets.append([x1, y1, x2, y2, conf])
    dets = np.array(dets)
    if len(dets) == 0:
        dets = np.empty((0, 5))

    tracks = tracker.update(dets)
    new_ids_this_frame = []
    for *xyxy, track_id in tracks:
        track_id = int(track_id)
        if track_id not in unique_ids:
            unique_ids.add(track_id)
            new_ids_this_frame.append(track_id)
        x1, y1, x2, y2 = map(int, xyxy)
        cx, cy = int((x1 + x2) / 2), int((y1 + y2) / 2)

        curr_side = bottom_mid_side_of_line((x1, y1, x2, y2), line_start, line_end)
        prev_side = last_box_side.get(track_id, curr_side)
        crosses = (prev_side != curr_side) and (curr_side != 0) and (prev_side != 0)
        inside_polygon = point_in_polygon((cx, cy), polygon_points)
        box_area = (x2-x1)*(y2-y1)
        car_crop = frame[y1:y2, x1:x2]

        
        if (light_state == "RED"
            and crosses
            and inside_polygon
            and track_id not in saved_ids):
            plates_buffer[track_id] = [(frame_num, car_crop, box_area)]
            saved_ids.add(track_id)
            print(f"Start saving car {track_id} plates at frame {frame_num}")

        if track_id in plates_buffer and len(plates_buffer[track_id]) < BUFFER_FRAMES:
            plates_buffer[track_id].append((frame_num, car_crop, box_area))
            if len(plates_buffer[track_id]) == BUFFER_FRAMES:
                best = max(plates_buffer[track_id], key=lambda t: t[2])
                best_frame, best_img, _ = best
                cv2.imwrite(f"snapshots/car_{track_id}_best_frame{best_frame}.jpg", best_img)
                print(f"Saved BEST plate for car {track_id} at frame {best_frame}")
                del plates_buffer[track_id]

        last_box_side[track_id] = curr_side
        cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 255), 2)
        cv2.putText(frame, f'ID {track_id}', (x1, y1 - 5),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)
        mid_bottom = (int((x1+x2)/2), int(y2))
        cv2.circle(frame, mid_bottom, 7, (0,0,255), -1)

    print(f"Frame {frame_num}: TL={light_state}, New Vehicles={len(new_ids_this_frame)}, Total Unique={len(unique_ids)}")
    results_per_frame.append((frame_num, light_state, len(unique_ids)))
    out.write(frame)

cap.release()
out.release()
df = pd.DataFrame(results_per_frame, columns=['frame', 'tl_state', 'total_unique_vehicles'])
df.to_csv('traffic_unique_vehicles.csv', index=False)
print("Saved traffic_unique_vehicles.csv")
